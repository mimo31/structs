type
	set,
	magma,
	unital_magma,
	semigroup,
	monoid,
	commutative_monoid,
	group,
	commutative_group,
	ring,
	commutative_ring,
	field,
	module,
	vector_space;

set
{
property
	empty,
	singleton,
	two-element,
	finite,
	infinite,
	cardinality_omega,
	cardinality_2^omega;

empty ! singleton ! two-element;
empty => finite;
singleton => finite;
two-element => finite;
cardinality_omega ! cardinality_2^omega;
cardinality_omega => infinite;
cardinality_2^omega => infinite;
finite * infinite;
}

magma
{
set set;

property
	unital,
	associative,
	commutative;

unital -> unital_magma;
associative -> semigroup;
}

unital_magma
{
magma magma;
set set = magma.set;

property
	associative,
	commutative;

associative -> monoid;

~set.empty;
}

semigroup
{
magma magma;
set set = magma.set;

property
	unital,
	commutative;

unital -> monoid;
}

monoid
{
unital_magma unital_magma;
semigroup semigroup;
unital_magma.magma = semigroup.magma;
magma magma = unital_magma.magma;
set set = magma.set;

property 
	commutative;

commutative -> commutative_monoid;
}

commutative_monoid
{
monoid monoid;
unital_magma unital_magma = monoid.unital_magma;
semigroup semigroup = monoid.semigroup;
magma magma = monoid.magma;
set set = magma.set;
}

group
{
monoid monoid;
unital_magma unital_magma = monoid.unital_magma;
semigroup semigroup = monoid.semigroup;
magma magma = monoid.magma;
set set = monoid.set;

property
	simple,
	commutative,
	cyclic,
	finite,
	trivial;

commutative -> commutative_group;

finite = set.finite;
trivial = set.singleton;
cyclic => commutative;
trivial => cyclic;
trivial => ~simple;
trivial => commutative;
}

commutative_group
{
group group;
commutative_monoid commutative_monoid;
group.monoid = commutative_monoid.monoid;
unital_magma unital_magma = group.unital_magma;
semigroup semigroup = group.semigroup;
monoid monoid = group.monoid;
magma magma = group.magma;
set set = group.set;

property
	simple,
	cyclic,
	finite,
	trivial;

simple = group.simple;
cyclic = group.cyclic;
trivial = group.trivial;
simple => cyclic;
cyclic => (set.finite | set.cardinality_omega);
finite = set.finite;
}

ring
{
commutative_group additive_group;
monoid multiplicative_monoid;
additive_group.set = multiplicative_monoid.set;
set set = additive_group.set;

property
	commutative,
	left-Artinian,
	right-Artinian,
	left-Noetherian,
	right-Noetherian,
	simple,
	characteristic_2,
	finite_characteristic,
	infinite_characteristic;

commutative -> commutative_ring;

left-Artinian => left-Noetherian;
right-Artinian => right-Noetherian;

characteristic_2 => finite_characteristic;
infinite_characteristic * finite_characteristic;

infinite_characteristic => set.infinite;
}

commutative_ring
{
ring ring;
commutative_group additive_group = ring.additive_group;
commutative_monoid multiplicative_monoid;
multiplicative_monoid.monoid = ring.multiplicative_monoid;
set set = ring.set;

property
	Artinian,
	Noetherian,
	field,
	characteristic_2,
	finite_characteristic,
	infinite_characteristic;

Artinian = ring.left-Artinian = ring.right-Artinian;
Noetherian = ring.left-Noetherian = ring.right-Noetherian;
field = ring.simple;
characteristic_2 = ring.characteristic_2;
finite_characteristic = ring.finite_characteristic;
infinite_characteristic = ring.infinite_characteristic;
}

field
{
commutative_ring ring;
commutative_group additive_group = ring.additive_group;
commutative_group multiplicative_group;
set set = ring.set;

property
	characteristic_2,
	finite_characteristic,
	infinite_characteristic,
	finite;

characteristic_2 = ring.characteristic_2;
finite_characteristic = ring.finite_characteristic;
infinite_characteristic = ring.infinite_characteristic;
additive_group.finite = multiplicative_group.finite;
finite = multiplicative_group.finite;
finite => multiplicative_group.simple;
finite => finite_characteristic;
additive_group.simple = additive_group.cyclic;
additive_group.simple => finite;
}

module
{
commutative_group addtiive_group;
ring ring;

property
	Artinian,
	Noetherian,
	simple,
	finitely-generated,
	cyclic;

simple => Artinian;
simple => Noetherian;
simple => cyclic;
cyclic => finitely-generated;
Noetherian => finitely-generated;
}

vector_space
{
module module;
field field;
module.ring = field.ring;

property
	one-dimensional,
	finite-dimensional;

one-dimensional = module.simple;
finite-dimensional = module.Artinian = module.Noetherian = module.finitely-generated;
}
